##编译环境要求
* Linux
* g++
* automake
* autoconf
* libtool
* make
* SDL2 ~~（目前还没实现绘图，所以暂时没有也没关系）~~
* SDL2_ttf
* SDL2_image
* OpenGL
* boost

在大多数发行版上应该都能在软件包管理器里找到，比如Ubuntu的apt-get。
理论上可以在Windows、MacOS上编译，但是需要进行一些调整。暂时只支持Linux。

##编译过程
在项目文件夹下执行：
```
mkdir m4
autoreconf -fi
./configure
make V=0
```
暂时不考虑安装的问题。

##运行
在项目文件夹下执行：
```
./main intro/intro.slide 840x480
或
./main intro/intro.slide 0x0
```
两个参数分别是要读取的文件名和窗口大小。`0x0`代表全屏。

用上面的方式运行，程序会读取`intro.slide`文件，然后在窗口里显示图形和文字。可以编辑`intro.slide`来使用自己系统中的图片和字体。具体请看“脚本文件格式”。

按上或左方向键回退到上一条指令，按其他任意键会切换到下一条指令。

##脚本文件格式
脚本文件指的是`*.slide`文件。文件中每一行用空格或Tab分割成若干个域，每行第一个域是命令，后面的所有域是它的参数。域可以用英文双引号（"）限定，所以当字体或图片文件路径里有空格的时候，需要用引号包围。

目前支持的命令：
* `newpage`
* `endpage`目前没有使用，计划通过这个支持slide结束时的自动切换延迟。
* `font {ttf file path}`指定接下来使用的字体文件。
* `fontsize {number}`指定字体大小。如果不指定，默认是0，所以文字可能无法显示。
* `fg {r} {g} {b} {a}`指定接下来使用的前景颜色。
* `bg {r} {g} {b} {a}`指定接下来使用的背景颜色。
* `rect {x} {y} {w} {h}`绘制矩形，填充颜色是之前指定的前景色。x、y、w、h分别是位置和大小。
* `img {x} {y} {image file path}`显示图片，x和y是图片左上角的位置。
* `text {x} {y} {text}`显示文字，x和y是文字区域左上角的位置。
* `point [rel] {x} {y}`定义一个点。这个点不会绘制，只是供其他指令参考，详见下面的说明。`rel`是可选的，如果有`rel`，那么后面的坐标是以屏幕中心为原点，而不是默认的屏幕左上角。注意：`rel`并不会改变坐标轴方向，只是平移而已。
* `mtext {x} {y} [{font} {text} | lb]...`多行文本，在坐标之后是任意个块，每块或者是一段文字，或者是newline。newline会将文字换到下一行显示。每块可以定义自己的字体和大小，规则同`font`指令，同时允许在字体字符串后紧跟字体大小，用一个冒号（:）分开。
* `aniline {x} {y} {sub-instruction}`将子指令绘制的图形沿直线移动到(x,y)。该指令可以嵌套，也就是子指令也可以是一个`aniline`，这样，最后一条指令绘制的图形将会被从后往前的每一条`aniline`依次移动。

对于所有指令，如果一行很长，可以用反斜杠断行，将参数分在不同的行书写。引号外多余的空格会自动忽略。

此外，所有的坐标参数都可以引用其他指令的位置，并映射到当前指令的五个不同坐标。引用的方式是使用为之前指令定义的id。

比如，脚本文件里之前的某条语句在任意位置有附加的参数"id=center"，那么后面的语句就可以通过"x:center"来引用前者的左上角X坐标。如果写"X:center"（大写X），那么就是被引用指令的右下角坐标。此外，如果是"x1:center"，那么将坐标替换为当前指令的左上角X坐标，如果是"x2:center"就是右上角，3、4、5分别是左下角、右下角和中央。

举例来说，对于以下语句：
```
point rel 0 0 id=center
text x5:center y5:center "hello"
```
Text将会显示在窗口的正中央，也就是将id为"center"的指令的（左上角）坐标带入到text的中央坐标（x5和y5）。

详细的应用可以参考`intro.slide`。

##指令插件开发方法
该项目中，除了核心部分以外，全部都是可选的插件，它们全部继承自Instruction抽象类，并由它进行查找和加载。

如果要开发一条新的指令，需要实现以下几个接口：（除非特别说明，这些都是指令类的成员函数。）
* 运行接口：`int run(GContext &);`。`GContext`是一个表示绘图所需环境的结构，包含SDL窗口和渲染器，当前使用的字体、字体大小和前景、背景颜色。该函数需要返回等待的时长，如果返回值`x>=0`，那么调用者会等待`x`毫秒的时间，让用户观看显示内容。如果返回值为`-1`，那么会无限等待，直到用户按下任意按键。如果返回值为`-2`，那么会马上开始执行下一条语句。注意，前两种返回值都不会马上执行下一条语句，而是会再次调用当前语句的`run`函数，这是为了允许嵌套执行。所以，新实现的语句必须在执行完后的某次调用中返回`-2`，否则程序会无限循环。
* 解释接口：`static bool explain(vector<string> prms, Instruction *&inst);`。这是一个静态函数，尝试解释给出的参数组`prms`。如果认定该参数是自己的语句，那么新建一个语句对象，将指针存放到`inst`中，并返回`true`；否则返回`false`。
* dlsym接口：`extern "C" Instruction::explain_t get_explain();`。这是一个按C语言方式导出的符号，便于负责加载的代码通过`dlsym`找到。不需要在头文件里写，只要在C++文件最后定义即可，而且它**不是指令对象的方法**，只是一个全局函数。该函数应该直接返回上面的`explain`函数指针。
* （可选）坐标接口：`void get_point(int *x, int *y);`。返回显示对象左上角的坐标。该函数只会在该语句开始执行之后调用，所以可以在`run()`的过程中计算。注意，如果要使用`Instruction`父类提供的坐标引用机制，将字符串形式的坐标转换成整数，那么它可能会依赖下面`get_size()`的结果。
* （可选）尺寸接口：`void get_size(int *w, int *h);`。返回显示对象的大小。同上，该函数需要的长和宽可以在`run()`里计算。但由于`get_point()`可能会依赖这个值，所以需要安排好`run()`里的计算顺序。一般的方法是在`run()`里先计算这个尺寸，因为它不需要依赖坐标。然后计算坐标，最后再绘图。可以参考`mtext.cpp`里的实现。
* （可选）回退接口：`bool runback(GContext &);`。当用户按下回退按键时，如果指令在回退路径上，那么该函数会被调用。如果返回true，表示回退成功，调用者不会再在那一层继续回退（记住指令嵌套的树形结构）；如果返回false，那么表示这一层已经在begin位置，需要父结点进行高层回退。实际上，有许多指令会在第一次调用`run()`时返回-1（或非负数），要求显示延迟，而第二次才返回-2，表示显示完成。对应地，在调用`runback()`之后，需要保证下一次调用`run()`时会正常地重绘一次，而不是继续之前的过程，直接返回-2。否则，用户回退之后，就无法再看到这条指令的内容。具体可以参考`image.cpp`里的写法。

如果指令不打算被解释，也可以不实现`explain`和`get_explain`。
另外，指令类不需要公开的构造函数，因为构造实际上是由`explain()`完成的。即便构造函数公开，加载者也没办法知道构造函数。其他代码都不会（也不需要）引用具体指令类的头文件。

由于有回退，需要保证所有指令可以被任意地重复执行。不仅在`runback()`里要注意重置状态，而且在`run()`里也要防止有副作用的计算被重复执行。

##已知问题
在有些系统环境下（比如Mac下虚拟机里的Ubuntu），`aniline`指令的动画效果无法正常显示。解决方法还在寻找中。
